Создание библиотеки SRT с поддержкой Python и шифрования
1. Установка и сборка SRT с поддержкой шифрования
1.1. Клонирование и сборка SRT
1.	Клонируем репозиторий SRT:
bash
# git clone https://github.com/Haivision/srt.git
# cd srt
2.	Создаём папку для сборки:
bash
# mkdir build && cd build
3.	Конфигурируем сборку с поддержкой шифрования:
bash
# cmake .. -DENABLE_ENCRYPTION=ON -DENABLE_AEAD_API_PREVIEW=ON
4.	Собираем и устанавливаем SRT:
bash
# make -j$(nproc)
# sudo make install
# sudo ldconfig
1.2. Проверка версии SRT
После сборки убедитесь, что версия SRT поддерживает шифрование:
bash
# srt-live-transmit --version
Версия библиотеки должна быть не ниже 1.5.4.
2. Создание Python-обёртки с использованием Pybind11
2.1. Подготовка окружения
1.	Установите зависимости для сборки:
bash
# sudo apt-get install cmake g++ python3-dev
# pip install pybind11 setuptools
2.2. Файлы проекта
Файл CMakeLists.txt
Этот файл используется для сборки проекта с помощью CMake:
#cmake
Копировать код
cmake_minimum_required(VERSION 3.12)
project(srt_python_module)

# Указываем стандарт C++
set(CMAKE_CXX_STANDARD 11)

# Находим pybind11
find_package(pybind11 REQUIRED)

# Находим библиотеку SRT
find_library(SRT_LIBRARY NAMES srt)
include_directories(/usr/local/include)

# Создаем модуль для Python
pybind11_add_module(srt_module srt_module.cpp)

# Линкуем библиотеку SRT
target_link_libraries(srt_module PRIVATE ${SRT_LIBRARY})
Файл srt_module.cpp
Это основной код, оборачивающий функции SRT для использования в Python через Pybind11:
cpp
Копировать код
#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <srt/srt.h>
#include <arpa/inet.h>

namespace py = pybind11;

// Маппинг опций сокета для использования в Python
std::unordered_map<std::string, SRT_SOCKOPT> socket_options = {
    {"SRTO_BINDTODEVICE", SRTO_BINDTODEVICE},
    {"SRTO_CONGESTION", SRTO_CONGESTION},
    {"SRTO_CONNTIMEO", SRTO_CONNTIMEO},
    {"SRTO_MAXBW", SRTO_MAXBW},
    {"SRTO_LATENCY", SRTO_LATENCY},
    {"SRTO_RCVBUF", SRTO_RCVBUF},
    {"SRTO_SNDBUF", SRTO_SNDBUF},
    {"SRTO_PAYLOADSIZE", SRTO_PAYLOADSIZE},
    {"SRTO_TLPKTDROP", SRTO_TLPKTDROP},
    {"SRTO_NAKREPORT", SRTO_NAKREPORT},
    {"SRTO_PASSPHRASE", SRTO_PASSPHRASE},
    {"SRTO_CRYPTOMODE", SRTO_CRYPTOMODE},  // Шифрование
    {"SRTO_TSBPDMODE", SRTO_TSBPDMODE}
};

// Установка опций сокета
void set_socket_option(SRTSOCKET sock, const std::string& option_name, const py::object& value) {
    auto it = socket_options.find(option_name);
    if (it == socket_options.end()) {
        throw std::invalid_argument("Unknown socket option: " + option_name);
    }
    SRT_SOCKOPT option = it->second;
    if (py::isinstance<py::int_>(value)) {
        int val = value.cast<int>();
        if (srt_setsockopt(sock, 0, option, &val, sizeof(val)) == SRT_ERROR) {
            throw std::runtime_error("Failed to set option: " + std::string(srt_getlasterror_str()));
        }
    } else if (py::isinstance<py::str>(value)) {
        std::string val = value.cast<std::string>();
        if (srt_setsockopt(sock, 0, option, val.c_str(), val.size()) == SRT_ERROR) {
            throw std::runtime_error("Failed to set option: " + std::string(srt_getlasterror_str()));
        }
    }
}

// Другие функции для подключения и приёма данных
int srt_connect_socket(SRTSOCKET sock, const std::string &ip, int port) {
    struct sockaddr_in sa;
    sa.sin_family = AF_INET;
    sa.sin_port = htons(port);
    inet_pton(AF_INET, ip.c_str(), &sa.sin_addr);
    if (srt_connect(sock, (struct sockaddr*)&sa, sizeof(sa)) == SRT_ERROR) {
        throw std::runtime_error("Failed to connect: " + std::string(srt_getlasterror_str()));
    }
    return 0;
}

py::bytes srt_recv_as_bytes(SRTSOCKET sock, int len) {
    std::vector<char> buf(len);
    int received_len = srt_recv(sock, buf.data(), len);
    if (received_len > 0) {
        return py::bytes(buf.data(), received_len);
    }
    return py::bytes();
}

PYBIND11_MODULE(srt_module, m) {
    m.def("set_socket_option", &set_socket_option, "Set SRT socket option");
    m.def("srt_startup", &srt_startup, "Initialize SRT");
    m.def("srt_create_socket", &srt_create_socket, "Create SRT socket");
    m.def("srt_connect", &srt_connect_socket, "Connect to SRT socket");
    m.def("srt_recv_as_bytes", &srt_recv_as_bytes, "Receive bytes via SRT");
}



Файл setup.py
Этот файл используется для сборки Python-модуля через setuptools:
python
Копировать код
from setuptools import setup, Extension
import pybind11

pybind11_include = pybind11.get_include()

srt_module = Extension(
    'srt_module',
    sources=['srt_module.cpp'],
    include_dirs=[pybind11_include, '/usr/local/include'],
    libraries=['srt'],
    library_dirs=['/usr/local/lib'],
    language='c++'
)

setup(
    name='srt_module',
    version='0.1',
    ext_modules=[srt_module],
    install_requires=['pybind11']
)
2.3. Сборка Python-модуля
1.	Запустите команду для сборки Python-обёртки:
bash
Копировать код
python3.7 setup.py build_ext --inplace
3. Использование Python-модуля
3.1. Пример кода на Python
Пример использования созданного модуля:
python
Копировать код
import srt_module

# Инициализация SRT
srt_module.srt_startup()

# Создание сокета
sock = srt_module.srt_create_socket()

# Установка опции шифрования
srt_module.set_socket_option(sock, "SRTO_PASSPHRASE", "mypassword")
srt_module.set_socket_option(sock, "SRTO_CRYPTOMODE", 1)

# Подключение к SRT серверу
srt_module.srt_connect(sock, "IP", Port)

# Приём данных
data = srt_module.srt_recv_as_bytes(sock, 1316)
print(data)
3.2. Поддерживаемые команды Python модуля
•	srt_startup – инициализация библиотеки SRT.
•	srt_create_socket – создание SRT сокета.
•	set_socket_option – установка опции сокета (например, для шифрования).
•	srt_connect – подключение к удалённому SRT серверу.
•	srt_recv_as_bytes – приём данных через SRT сокет в формате байтов.
3.3. Примеры команд для запуска
1.	Запуск SRT-сервера с входом и выходом на шифрованные каналы:
bash
Копировать код
# python3.7 srt_server.py srt://IP: Port#mykey srt://: Port#mykey
2.	Запуск для пересылки из SRT в UDP:
bash
Копировать код
# python3.7 srt_server.py srt://IP:Port udp://127.0.0.1: Port
4. Важные моменты
•	Для поддержки шифрования необходимо использовать опции SRTO_PASSPHRASE и SRTO_CRYPTOMODE.
•	SRT библиотека должна быть собрана с флагами ENABLE_ENCRYPTION=ON и ENABLE_AEAD_API_PREVIEW=ON.
•	Pybind11 используется для создания интерфейса между Python и C++.

